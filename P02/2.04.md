## 4. Dado un aut√≥mata finito para $\mathcal{L}$, indicar c√≥mo construir aut√≥matas finitos para los siguientes lenguajes. Indicar en cada caso si es necesario que el aut√≥mata de entrada sea determin√≠stico o no, y de qu√© tipo es el aut√≥mata resultante.

### a) $\mathcal{L}^c$, el complemento de $\mathcal{L}$.

Basta con reemplazar el conjunto de estados finales por $F' = Q \backslash F$.

El aut√≥mata debe ser determin√≠stico. El aut√≥mata resultante tambi√©n es determin√≠stico. 

Un contraejemplo para el caso no determin√≠stico:

<p align="center"><img src="./media/2.04.a.svg"></p>

Tal vez funcione complementar sobre la clausura $\lambda$ de los estados finales para el caso AFND-$\lambda$.

### b) $\mathcal{L}^‚àó$, la clausura de Kleene de $\mathcal{L}$.

Hay que:

1. volver al estado inicial un estado final, tal que acepte $\lambda$.
2. para cada transici√≥n desde el estado inicial, hay que agregar la misma transici√≥n desde cada uno de los estados finales.

Por ejemplo:

<p align="center"><img src="./media/2.04.b.svg"></p>

Si una transici√≥n a agregar ya existe para alg√∫n estado final $f$ (hacia alg√∫n otro estado), o bien convertimos el aut√≥mata a un AFND, o bien:

1. buscamos todos los puntos de quiebre m√≠nimos (en tanto equivalencia) entre las cadenas de estados a partir de $f$ y las cadenas de estados a partir del estado inicial.

2. agregamos, por cada uno, una transici√≥n desde el nodo que quiebra desde $f$ hacia el nodo 'faltante' que sigue en la cadena 'equivalente' a partir del estado inicial, tal que se pueda 'continuar' con la equivalencia. Estas transiciones siempre se podr√°n hacer, en tanto existan los puntos de quiebre (si la transici√≥n estuviera siendo 'usada', no ser√≠a un punto de quiebre). Si un punto de quiebre no existe, entonces el aut√≥mata ya contempla 'repetir' ese prefijo en particular.

Por ejemplo:

<p align="center"><img src="./media/2.04.b2.svg"></p>

donde las transiciones con * son las agregadas.

Luego, est√° transformaci√≥n se puede hacer para cualquier tipo de aut√≥mata y el aut√≥mata resultante es del mismo tipo.

### c) $\mathcal{L}^r$, la reversa de $\mathcal{L}$.

Basta con:

1. cambiar la direcci√≥n de todas las transici√≥n.
2. volver el estado inicial en un estado final.
3. Agregar un estado nuevo 'inicial', que por transiciones $\lambda$ se una a los finales anteriores.

Esto se puede realizar para cualquier aut√≥mata y el aut√≥mata resultante es AFND-$\lambda$.

### d) $Ini(\mathcal{L})=\{\alpha\ |\ \exists \beta\ \text{tal que}\ \alpha \beta \in \mathcal{L}\}$, los prefijos de $\mathcal{L}$.

Basta con convertir a todos los estados en estados finales.

Sirve para todo tipo de aut√≥mata y el aut√≥mata resultante es del mismo tipo que el de entrada.

### e) $Fin(\mathcal{L})=\{\alpha\ |\ \exists \gamma\ \text{tal que}\ \gamma \alpha \in \mathcal{L}\}$, los sufijos de $\mathcal{L}$.

Basta con agregar transiciones $\lambda$ desde el estado inicial a todo el resto de los estados. 

Esto se puede realizar para cualquier aut√≥mata y el aut√≥mata resultante es AFND-$\lambda$.

### f) $Sub(\mathcal{L})=\{\alpha\ |\ \exists (\beta,\ \gamma)\ \text{tales que}\ \gamma \alpha \beta \in \mathcal{L}\}$, las subcadenas de $\mathcal{L}$.

Basta con realizar las transformaciones de la parte (d) y (e). 

Esto se puede realizar para cualquier aut√≥mata y el aut√≥mata resultante es AFND-$\lambda$.

### g) $\max(\mathcal{L})=\{\alpha \in \mathcal{L}\ |\ \forall \omega \in \Sigma^+,\alpha \omega \notin \mathcal{L}\}$, las cadenas maximales de $\mathcal{L}$.

Para empezar, notar que si el aut√≥mata relacionado a $\mathcal{L}$ tiene ciclos, entonces $\max(\mathcal{L})$ es vac√≠o.

Dicho esto, podemos realizar la siguiente transformaci√≥n:

1. Si el aut√≥mata tiene ciclos, devolver alg√∫n aut√≥mata para el lenguaje vac√≠o (ej. $(\{q_0, T\}, \Sigma, \delta: \delta(x) = T, q_0, \emptyset)$).
2. Si no:
    1. eliminar cualquier cadena 'in√∫til'. Es decir, que no conduzca a un estado final.
    2. armar un √°rbol de caminos m√°ximos a partir del estado inicial (con bellman-ford y un peso de -1 por transici√≥n, por ejemplo).
    3. para cada estado final $f$, si $f$ no est√° a profundidad m√°xima en el √°rbol:
        1. remover $f$ del conjunto de estados finales.

El aut√≥mata resultante es de la misma clase que el de entrada. El aut√≥mata de entrada no tiene restricciones.

### h) $\min(\mathcal{L})=\{\alpha \in \mathcal{L}\ |\ \text{ning√∫n prefijo propio de}\ \alpha\ \text{pertenece a}\ \mathcal{L}\}$, las cadenas minimales de $\mathcal{L}$. Es decir, $\min(\mathcal{L})=\{\alpha \in \mathcal{L}\ |\ \nexists(\omega_1,\omega_2)\ \text{tales que}\ \alpha = \omega_1\omega_2 \ \wedge\ \omega_1\in \mathcal{L}\ \wedge\ \omega_2\neq\lambda\}$.

Podemos realizar la siguiente transformaci√≥n:

1. para cada estado final $f_i$:
    1. para toda transici√≥n $t$ desde $f_i$ que conduzca a alg√∫n otro estado final $f_j$ (incluyendo $i = j$):
        1. eliminar $t$
2. eliminar toda componente que haya quedado desconexa al estado inicial.

El aut√≥mata de entrada tiene que ser determin√≠stico. Si no, podr√≠a pasar que haya dos cadenas aceptadas por el lenguaje, tal que una es prefijo de la otra, pero que no comparten 'camino' (notar que una manera sencilla de resolver esto es primero transformar al aut√≥mata en uno determin√≠stico).

El aut√≥mata resultante tambi√©n es determin√≠stico.

### i) $\mathcal{L}_ùëá=\{\alpha \in \Sigma^‚àó\ |\ \exists (\omega_1 \in \mathcal{L},\omega_2\in \Sigma^‚àó)\ \text{tales que}\ \alpha =\omega_1\omega_2\}=\mathcal{L}.\Sigma^‚àó$.

Una forma sencilla ser√≠a agregar a cada estado final un loop que tome cualquier s√≠mbolo en $\Sigma$. Con un juego similar al de la parte (b) probablemente podr√≠amos evitar convertir el aut√≥mata en no determin√≠stico. 

El aut√≥mata de entrada puede ser de cualquier clase. El de salida es no determin√≠stico.
